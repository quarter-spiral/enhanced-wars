{
  "fullname": "Calamity",
  "name": "calamity",
  "version": "0.5.0-rc.5",
  "description": "An event bus library for event-driven applications.",
  "keywords": [
    "events",
    "pubsub"
  ],
  "homepage": "https://bitbucket.org/kennethjor/calamity",
  "bugs": "https://bitbucket.org/kennethjor/calamity/issues",
  "author": {
    "name": "Kenneth Jorgensen",
    "email": "kennethjor@gmail.com",
    "url": "http://kennethjorgensen.com/"
  },
  "main": "calamity.js",
  "repository": {
    "type": "hg",
    "url": "ssh://hg@bitbucket.org/kennethjor/calamity"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://bitbucket.org/kennethjor/calamity/raw/default/LICENSE"
    }
  ],
  "dependencies": {
    "underscore": ">= 1.4.4"
  },
  "devDependencies": {
    "grunt": "~ 0.4",
    "grunt-contrib-concat": "~ 0.1.3",
    "grunt-contrib-coffee": "~ 0.6.0",
    "grunt-contrib-uglify": "~ 0.2.0",
    "grunt-contrib-nodeunit": "~ 0.1.2",
    "grunt-contrib-watch": "~ 0.3.1",
    "grunt-jessie": "~ 0.0.1",
    "async": "~ 0.1.22",
    "sinon": "~ 1.6.0",
    "doxx": "~ 0.5.9"
  },
  "readme": "# Calamity\nCalamity allows you to drive your application through a global event bus, facilitating loosely-coupled event-driven architectures.\nAvailable via [npm](https://npmjs.org/package/calamity): `npm install calamity`.\n\n# Local event busses with `emitter()`.\nLocal event busses are used on individual classes and objects to allow them to publish events others can subscribe to.\nWhen attaching a local event bus, two methods are made available: `on()` and `trigger()`.\n\n## `on(address, handler(msg) )`\nAttaches the function `handler(msg)` to be executed when `address` is triggered.\nWhen `handler` is executed, Calamity will automatically bind its execution to the subscribing object.\n\n## `trigger(address [, data [, replier(reply) ] ] )`\nTriggers any handlers attached to `address`.\n`data` is an arbitrary object which will be provided to the handler via its message.\n`replier` is a secondary handler function which will be executed in case the main handler executes a reply (more on this later).\n\n## Local events example\nConsider this imaginary `View` class:\n\n    :::coffeescript\n    Calamity = require \"calamity\"\n    _ = require \"underscore\"\n\n    class View\n    \tCalamity.emitter @prototype\n\n    \trender:\n    \t\t@trigger \"beforeRender\"\n    \t\t_.defer =>\n    \t\t\t# Real render code ...\n    \t\t\t@element.find(\"#closeButton\").click =>\n    \t\t\t\t@trigger \"closeButtonClicked\"\n    \t\t@trigger \"afterRender\"\n\nNow using the `on()` method, any code with a reference to the view can subscribe to events coming out of it.\nIn this example we can act on the view starting and finishing its render routine.\nAdditionally, the view attaches to the click event on a DOM element, propagating it to a Calamity event on the view itself, thereby abstracting it away.\n\n    :::coffeescript\n    view = new View()\n    view.on \"closeButtonClicked\", ->\n    \tview.hide()\n\n# Global event bus with `proxy()`\nA more powerful example of Calamity is using it as a global event bus which spans your entire application.\nThe global event bus proxy attaches three methods: `subscribe()`, `publish()` and `send()`.\n\n## `subscribe( address, handler(msg) )`\nAttaches the function `handler(msg)` to be executed when messages are published or sent to `address`.\nWhen `handler` is executed, Calamity will automatically bind its execution to the subscribing object.\n\n## `publish( address [, data [, replier(reply) ] ] )`\nSends a message to `address`.\n`data` is an arbitrary object which will be provided to the handler via its message.\n`replier` is a secondary handler function which will be executed in case the main handler executes a reply (more on this later).\n\n## `send( address [, data [, replier(reply) ] ] )`\nWorks exactly like `publish()` with the notable difference that only one subscribing handler will be executed.\nThis is useful for sending commands instead events.\n\n## Global events example\n\n    :::coffeescript\n    Calamity = require \"calamity\"\n    class Foo\n    \tCalamity.proxy @prototype\n\n    \tconstructor: () ->\n    \t\t@subscribe \"address\", @handler\n\n    \thandler: (msg) ->\n    \t\t# Proxy automatically handles binding to this.\n    \t\t@data = msg.data\n\nNow, whenever any object publishes a message to the `foo:bar` address, handler will be called and you can react on it.\n\n# Events and commands\n*Events* tell of something which happened and are transmitted using `trigger()` and `publish()`.\nNormally events will not be replied to and will originate from a single source.\n\n*Commands* are instructions to perform an action and are transmitted using `send()`.\nThe local events mixin does not include a mechanism for sending commands.\nCommands are much more likely to send replies than events, as they often need to report on their progress.\nCommands will usually only be subscribed to by a single object type, and be sent from many.\n\nWithin Calamity there is no real difference between an event and a command, other than the method used for sending it.\nBoth of them use the `EventMessage` class to contain themselves.\n\n# Working with messages\nWhen subscribing to an address, the attached handler is expected to accept a single argument: an `EventMessage` object.\nThis object encapsulates the entire message and everything that can be done with it.\n\n## EventMessage properties\nThe following properties are available on `EventMessage`:\n\n* `msg.address`: The address the message was sent to.\n* `msg.data`: The raw data object supplied on creation.\n* `msg.status`: The status of the message. This can beeither \"ok\" or \"error\". Error is used by `replyError()`. To check for erros, `isError()` should be used.\n* `msg.error`: If `msg.status` is \"error\", this will contain the error supplied to `replyError()`.\n\n## EventMessage methods\nThe following methods can be used to interact with the message:\n\n* `getOptional( param, default )`: Returns a value from `msg.data`. If the value does not exist, the supplied `default` is returned.\n* `getRequried( param )`: Returns a value from `msg.data`. IF the value does not exist, an `Error` is thrown.\n* `reply( data[, replier(msg) ] )`: Sends a reply to the sender.\n* `replyError( error[, replier(msg) ] )`: Sends an error reply to the sender.\n* `isError()`: Returns true if the message represents an error. The supplied error is available via `msg.error`.\n\n# Replying to messages\n\n# License\nCalamity is licensed and freely distributed under the [MIT License][mit]\n\n[mit]: https://bitbucket.org/kennethjor/calamity/raw/default/LICENSE \"MIT License\"\n",
  "_id": "calamity@0.5.0-rc.5",
  "_from": "calamity@~0.5.0-rc.5"
}
